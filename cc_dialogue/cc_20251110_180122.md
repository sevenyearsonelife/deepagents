# Chat Dialogue Log

## 对话时间
2025-11-10 18:01:22

---

## 对话内容

### 问题 1
用户：libs文件夹下有2个文件夹deepagents和deepagents-cli。这两个文件夹分别有什么作用？

助手：根据我对代码的分析，`libs` 文件夹下的两个项目具有明确的分工：

## deepagents - 核心库

`deepagents` 是整个项目的核心框架库，提供构建 AI 智能体的基础设施：

**核心组件：**
- `graph.py`: 主要的 `create_deep_agent` 函数，创建配置完整的深度智能体
- `middleware/`: 模块化中间件系统
  - `filesystem.py`: 文件系统交互工具
  - `subagents.py`: 子智能体生成和上下文隔离
  - `resumable_shell.py`: 可恢复的 shell 工具
- `backends/`: 可插拔的存储后端系统

**设计理念：**
这是一个库级别的框架，采用中间件架构模式，让开发者可以组合不同的功能模块来构建定制的 AI 智能体。

## deepagents-cli - 命令行应用

`deepagents-cli` 是基于核心库构建的命令行工具，提供用户交互界面：

**主要功能：**
- `main.py`: CLI 主入口和交互循环
- `agent.py`: 智能体管理和配置
- `ui.py`: 基于 Rich 库的现代化终端界面
- CLI 专用工具：HTTP 请求、网络搜索、Shell 执行等

**应用特点：**
提供完整的用户交互体验，包括彩色输出、多行编辑、状态持久化等功能。

`★ Insight ─────────────────────────────────────`
• 这种库-应用分离的设计模式使得框架既可作为依赖库被其他项目集成，也可作为独立工具直接使用
• 中间件架构实现了功能的模块化和可组合性，开发者可以按需选择和配置功能组件
• 存储后端的抽象设计支持多种存储方案，从文件系统到数据库都可以无缝切换
`─────────────────────────────────────────────────`

两个项目的关系是：`deepagents-cli` 依赖于 `deepagents`，是核心库的一个具体应用实现，展示了如何使用这个框架构建完整的 AI 助手应用。

---

### 问题 2
用户：请详细解释deepagents文件夹的构成

助手：## deepagents 文件夹详细构成解析

基于我对代码的深入分析，`deepagents` 文件夹采用清晰的模块化架构，主要包含以下核心组件：

### 1. 根目录核心文件

**`__init__.py`** - 包的公共接口
- 导出核心功能：`create_deep_agent`、`FilesystemMiddleware`、`SubAgentMiddleware` 等
- 定义了对外暴露的 API 边界

**`graph.py`** - 智能体创建核心
- `create_deep_agent()`: 主要的智能体工厂函数 (graph.py:40)
- 默认模型配置：Claude Sonnet 4 (`claude-sonnet-4-5-20250929`) (graph.py:35)
- 标准中间件栈配置 (graph.py:97-125)

### 2. middleware/ 中间件系统

**架构设计理念：**
中间件模式实现功能的模块化和可组合性，每个中间件负责特定的功能领域。

**核心中间件：**

**`filesystem.py`** - 文件系统中间件
- 提供文件操作工具：`write_file`、`ls`、`read_file`、`edit_file`、`glob_search`、`grep_search`
- `FileData` 类型定义：存储文件内容和元数据 (filesystem.py:38-50)
- `_file_data_reducer`: 文件数据的合并与删除策略 (filesystem.py:51-84)

**`subagents.py`** - 子智能体中间件
- `SubAgent` 类型定义：子智能体规范 (subagents.py:17-46)
- `task` 工具：启动临时子智能体处理复杂任务 (subagents.py:66-80)
- 支持上下文隔离和并发执行

**其他中间件：**
- `resumable_shell.py`: 可恢复的 shell 工具中间件
- `patch_tool_calls.py`: 工具调用补丁中间件

### 3. backends/ 存储后端架构

**设计模式：**
策略模式 + 抽象工厂模式，通过 `BackendProtocol` 统一接口，支持多种存储实现。

**核心组件：**

**`protocol.py`** - 后端协议定义
- `BackendProtocol`: 所有后端必须实现的接口 (protocol.py:1-6)
- `WriteResult`、`EditResult`: 操作结果类型定义 (protocol.py:37-80)
- `FileInfo`、`GrepMatch`: 结构化数据类型 (protocol.py:15-34)

**后端实现：**
- `filesystem.py`: 直接文件系统存储
- `state.py`: LangGraph 状态存储
- `store.py`: LangGraph Store 存储
- `composite.py`: 多后端组合策略

### 4. tests/ 测试架构

**分层测试策略：**

**单元测试** (`unit_tests/`)
- `test_middleware.py`: 中间件组件测试
- `backends/`: 各种后端实现的独立测试
- 验证组件行为的正确性

**集成测试** (`integration_tests/`)
- `test_deepagents.py`: 完整工作流测试
- `test_filesystem_middleware.py`: 文件系统中间件集成测试
- `test_subagent_middleware.py`: 子智能体中间件集成测试
- `test_hitl.py`: 人机交互功能测试

**测试工具** (`utils.py`)
- `assert_all_deepagent_qualities()`: 验证深度智能体标准功能 (utils.py:8-17)
- 模拟工具和中间件定义

`★ Insight ─────────────────────────────────────`
• 中间件架构采用了洋葱模式，每个中间件都可以处理请求和响应，实现了功能的横切关注点分离
• 后端系统的抽象设计使得文件存储可以无缝切换，从内存到分布式存储都能支持
• 测试分层策略确保了组件的独立性和整体功能的正确性，这是成熟软件架构的标志
`─────────────────────────────────────────────────`

### 5. 默认配置与约定

**默认中间件栈顺序：**
1. `TodoListMiddleware`: 任务规划和分解
2. `FilesystemMiddleware`: 文件系统交互
3. `SubAgentMiddleware`: 子智能体支持
4. `SummarizationMiddleware`: 对话摘要管理
5. `AnthropicPromptCachingMiddleware`: 提示缓存优化
6. `PatchToolCallsMiddleware`: 工具调用增强

**核心工具集：**
- `write_todos`: 规划工具
- 文件操作六件套：`write_file`、`ls`、`read_file`、`edit_file`、`glob_search`、`grep_search`
- `task`: 子智能体启动工具

这种架构设计体现了现代软件工程的最佳实践：模块化、可扩展性、测试友好性和关注点分离。

---

### 问题 3
用户：middleware文件夹的作用是什么？

助手：## middleware 文件夹的作用详解

`middleware` 文件夹是 DeepAgents 框架的核心组件，实现了基于中间件模式的智能体功能扩展架构。

### 1. 整体架构设计理念

**中间件模式（Middleware Pattern）：**
采用洋葱模型，每个中间件都可以在智能体处理请求和响应的各个阶段进行干预和增强，实现横切关注点的分离。

`★ Insight ─────────────────────────────────────`
• 中间件架构实现了功能的可插拔性和可组合性，开发者可以根据需要选择和定制中间件栈
• 每个中间件都有明确的职责边界，遵循单一职责原则，便于测试和维护
• 中间件通过标准化的生命周期钩子（before_agent、after_agent等）与智能体核心逻辑交互
`─────────────────────────────────────────────────`

### 2. 核心中间件详细解析

#### 2.1 FilesystemMiddleware - 文件系统中间件

**核心功能：**
为智能体提供完整的文件系统交互能力，包含六个核心工具：

**安全机制：**
- `_validate_path()`: 防止目录遍历攻击 (filesystem.py:87-129)
- 路径规范化：统一使用前导斜杠和正斜杠格式
- 可选的路径前缀限制，增强安全性

**工具集合：**
- `ls`: 目录列表工具 (filesystem.py:139-145)
- `read_file`: 文件读取工具，支持分页和大文件处理 (filesystem.py:147-162)
- `write_file`: 文件写入工具 (filesystem.py:175-181)
- `edit_file`: 精确字符串替换工具 (filesystem.py:164-172)
- `glob`: 文件模式匹配工具 (filesystem.py:184-195)
- `grep`: 文本搜索工具 (filesystem.py:197-212)

**状态管理：**
- `FilesystemState`: 专门的状态类型 (filesystem.py:132-136)
- `_file_data_reducer`: 文件数据的合并与删除策略 (filesystem.py:51-84)

#### 2.2 SubAgentMiddleware - 子智能体中间件

**核心功能：**
提供 `task` 工具，用于生成专门的子智能体来处理复杂任务：

**子智能体规范：**
- `SubAgent`: 定义子智能体的配置结构 (subagents.py:17-46)
- `CompiledSubAgent`: 预编译的子智能体实例 (subagents.py:48-59)

**使用场景和原则：**
- 复杂多步骤任务的委托执行 (subagents.py:181-198)
- 并行任务处理和上下文隔离
- 减少主智能体的 token 使用和上下文复杂度

**详细使用指南：**
中间件提供了丰富的使用示例，包括：
- 代码审查任务示例 (subagents.py:139-157)
- 研究分析任务示例 (subagents.py:160-166)
- 并行任务处理示例 (subagents.py:112-119)

#### 2.3 ResumableShellToolMiddleware - 可恢复 Shell 中间件

**核心问题解决：**
解决标准 `ShellToolMiddleware` 在人机交互（HITL）暂停后无法恢复 shell 会话的问题 (resumable_shell.py:20-33)

**技术实现：**
- 懒加载会话资源创建 (resumable_shell.py:76-83)
- 会话资源存在性检查 (resumable_shell.py:71-74)
- 智能的资源清理策略 (resumable_shell.py:63-70)

#### 2.4 PatchToolCallsMiddleware - 工具调用补丁中间件

**核心功能：**
处理消息历史中的"悬挂"工具调用，防止状态不一致：

**问题识别：**
- 检测 AI 消息中未完成工具调用 (patch_tool_calls.py:24-30)
- 自动生成取消消息，保持对话历史的完整性 (patch_tool_calls.py:32-42)

### 3. 中间件工作原理和交互机制

#### 3.1 生命周期钩子

每个中间件都实现了标准的生命周期方法：

**before_agent():**
- 在智能体执行前进行预处理
- 状态验证和初始化
- 工具调用历史修复

**after_agent():**
- 在智能体执行后进行后处理
- 资源清理和状态持久化

#### 3.2 中间件栈执行顺序

在 `create_deep_agent()` 中的默认中间件栈顺序 (graph.py:97-125)：

1. **TodoListMiddleware**: 任务规划
2. **FilesystemMiddleware**: 文件系统交互
3. **SubAgentMiddleware**: 子智能体支持
4. **SummarizationMiddleware**: 对话摘要
5. **AnthropicPromptCachingMiddleware**: 提示缓存
6. **PatchToolCallsMiddleware**: 工具调用修复

### 4. 中间件在深度智能体中的关键作用

#### 4.1 功能模块化
- 每个中间件负责特定的功能领域
- 通过组合实现复杂的功能集合
- 便于单独测试、维护和升级

#### 4.2 状态管理
- 中间件可以定义自己的状态结构
- 通过 reducer 函数处理状态合并
- 支持持久化和恢复机制

#### 4.3 工具注入
- 中间件可以向智能体注入专用工具
- 工具描述自动集成到系统提示中
- 支持动态工具配置和管理

#### 4.4 安全和可靠性
- 路径验证和权限控制
- 错误处理和恢复机制
- 资源管理和泄漏防护

`★ Insight ─────────────────────────────────────`
• 中间件架构使得 DeepAgents 能够像搭积木一样组合不同的能力，同时保持每个组件的独立性和可测试性
• 这种设计模式特别适合 AI 智能体系统，因为不同的任务可能需要不同的工具组合和配置策略
• 中间件的分层处理确保了功能的解耦，使得系统更容易扩展和维护
`─────────────────────────────────────────────────`

总结来说，`middleware` 文件夹实现了一个强大的中间件生态系统，为 DeepAgents 提供了文件操作、子智能体管理、Shell 交互和工具调用修复等核心能力，构成了深度智能体功能扩展的基础架构。

---

### 问题 4
用户：backends文件夹的作用是什么？

助手：## backends 文件夹的作用详解

`backends` 文件夹实现了 DeepAgents 的可插拔存储架构，提供了统一的文件操作接口，支持多种存储后端。

### 1. 整体架构设计理念

**策略模式（Strategy Pattern）：**
定义了一套统一的文件操作接口，不同的后端实现可以互换使用，为智能体提供灵活的存储选择。

**抽象工厂模式：**
通过 `BackendFactory` 类型别名 (protocol.py:148)，支持运行时动态创建后端实例。

`★ Insight ─────────────────────────────────────`
• 后端系统的设计让智能体可以无缝切换存储策略，从临时内存到持久化数据库，而不需要改变上层代码
• 统一的协议接口确保了不同存储方案的一致性体验，这是构建可扩展系统的重要设计原则
• 组合后端的设计支持复杂的存储拓扑，可以同时使用多种存储策略来优化不同场景的性能
`─────────────────────────────────────────────────`

### 2. 协议定义和接口设计

#### 2.1 BackendProtocol - 核心协议接口

**接口规范 (protocol.py:88-146)：**
```python
@runtime_checkable
class BackendProtocol(Protocol):
    def ls_info(self, path: str) -> list["FileInfo"]: ...
    def read(self, file_path: str, offset: int = 0, limit: int = 2000) -> str: ...
    def grep_raw(self, pattern: str, path: str | None = None, glob: str | None = None) -> list["GrepMatch"] | str: ...
    def glob_info(self, pattern: str, path: str = "/") -> list["FileInfo"]: ...
    def write(self, file_path: str, content: str) -> WriteResult: ...
    def edit(self, file_path: str, old_string: str, new_string: str, replace_all: bool = False) -> EditResult: ...
```

**设计特点：**
- 使用 Python 的 `Protocol` 类型实现鸭子类型接口
- `@runtime_checkable` 装饰器支持运行时类型检查
- 统一的文件数据格式：内容 + 时间戳元数据

#### 2.2 结构化数据类型

**FileInfo (protocol.py:15-26)：**
- 最小化文件信息契约，只有 `path` 是必需的
- 支持可选的元数据：`is_dir`、`size`、`modified_at`

**WriteResult 和 EditResult (protocol.py:37-86)：**
- 统一的操作结果格式
- 区分检查点存储和外部存储的结果格式
- 包含错误处理和状态更新信息

### 3. 各种后端实现的特点和用途

#### 3.1 FilesystemBackend - 文件系统后端

**核心特点：**
- 直接操作物理文件系统
- 支持安全路径解析和沙箱模式 (filesystem.py:52-81)
- 集成 ripgrep 进行高性能搜索

**安全机制：**
- **虚拟模式**：限制操作在根目录内，防止路径遍历攻击 (filesystem.py:66-75)
- **符号链接保护**：使用 `O_NOFOLLOW` 防止恶意符号链接
- **文件大小限制**：默认最大 10MB 文件，防止内存溢出

**适用场景：**
- 需要持久化文件存储的场景
- 开发环境和代码编辑任务
- 与现有文件系统集成

#### 3.2 StateBackend - 状态存储后端

**核心特点：**
- 基于 LangGraph 的状态管理机制
- 临时存储，仅在对话线程内持久化 (state.py:20-30)
- 自动检查点，支持状态恢复

**工作原理：**
- 文件数据存储在 `runtime.state["files"]` 中
- 通过 `Command` 对象进行状态更新
- 支持虚拟目录结构和文件元数据

**适用场景：**
- 短期任务和临时文件处理
- 需要状态检查点和恢复的场景
- 对话内的文件操作

#### 3.3 StoreBackend - 持久化存储后端

**核心特点：**
- 基于 LangGraph 的 `BaseStore` 接口
- 跨对话线程的持久化存储 (store.py:20-27)
- 支持多智能体隔离

**命名空间管理：**
- 智能命名空间解析 (store.py:51-87)
- 支持按 `assistant_id` 进行多智能体隔离
- 灵活的配置优先级策略

**适用场景：**
- 需要长期持久化的重要文件
- 多智能体环境下的文件共享
- 生产环境的数据持久化需求

#### 3.4 CompositeBackend - 组合后端

**核心特点：**
- 基于路径前缀的路由机制 (composite.py:22-42)
- 支持多个后端的智能组合
- 透明的路径映射和结果聚合

**路由策略：**
- 最长前缀匹配优先 (composite.py:19-21)
- 虚拟路径到后端路径的映射
- 根目录的聚合视图

**适用场景：**
- 复杂的存储拓扑需求
- 不同类型文件的差异化存储策略
- 存储系统的渐进式迁移

### 4. 后端工厂模式和组合策略

#### 4.1 BackendFactory 类型别名

**定义 (protocol.py:148)：**
```python
BackendFactory: TypeAlias = Callable[[ToolRuntime], BackendProtocol]
```

**作用：**
- 支持延迟后端初始化
- 允许基于运行时配置选择后端
- 简化后端依赖注入

#### 4.2 在 FilesystemMiddleware 中的应用

在 `filesystem.py` 中，后端工厂通过以下方式使用：
```python
def _get_backend(backend: BACKEND_TYPES, runtime: ToolRuntime) -> BackendProtocol:
    if callable(backend):
        return backend(runtime)  # 工厂函数调用
    return backend  # 直接实例
```

#### 4.3 组合策略的实际应用

**典型配置示例：**
```python
# 组合后端配置
composite = CompositeBackend(
    default=StateBackend(runtime),  # 默认临时存储
    routes={
        "/persistent/": StoreBackend(runtime),  # 持久化路由
        "/temp/": FilesystemBackend("/tmp"),     # 临时文件路由
    }
)
```

`★ Insight ─────────────────────────────────────`
• 后端系统的抽象设计使得存储策略可以像插件一样热插拔，这是构建灵活 AI 系统的关键
• 组合后端的路由机制支持复杂的存储拓扑，可以针对不同文件类型采用最优的存储策略
• 工厂模式的使用提供了延迟初始化和依赖注入的能力，增强了系统的可配置性和可测试性
`─────────────────────────────────────────────────`

### 5. 工具函数和辅助模块

**utils.py** 提供了共享的工具函数：
- `format_content_with_line_numbers()`: 格式化文件内容 (utils.py:38-50)
- `sanitize_tool_call_id()`: 安全化工具调用ID (utils.py:29-35)
- 搜索和模式匹配函数
- 文件数据转换和验证函数

### 6. 架构优势

**可扩展性：**
- 新的存储后端只需实现 `BackendProtocol` 接口
- 支持第三方存储系统的无缝集成

**灵活性：**
- 运行时动态选择存储策略
- 支持复杂的存储组合和路由规则

**可靠性：**
- 统一的错误处理和结果格式
- 完整的类型注解和运行时检查
- 全面的单元测试覆盖

总结来说，`backends` 文件夹实现了一个高度抽象和可扩展的存储系统，为 DeepAgents 提供了从临时内存到持久化数据库的全谱系存储解决方案，满足了不同应用场景的存储需求。

---

### 问题 5
用户：如何使用deepagents？结合具体的示例进行讲解，并剖析内部执行流程。

助手：## DeepAgents 使用指南与执行流程详解

我将通过具体示例详细讲解如何使用 DeepAgents，并剖析其内部执行流程。

### 1. 基础使用示例

#### 1.1 最简单的 DeepAgent

```python
from deepagents import create_deep_agent
from langchain_core.messages import HumanMessage

# 创建基础深度智能体
agent = create_deep_agent()

# 与智能体交互
result = agent.invoke({
    "messages": [HumanMessage(content="你好，请介绍一下你的功能")]
})

print(result["messages"][-1].content)
```

`★ Insight ─────────────────────────────────────`
• 即使是最简单的 create_deep_agent() 调用，也会自动配置完整的中间件栈，包括文件操作、任务规划和子智能体支持
• 默认配置已经包含了生产环境所需的核心功能，开发者可以直接使用而无需额外配置
• 智能体会自动获得标准工具集：write_todos、文件操作六件套、task 子智能体工具
`─────────────────────────────────────────────────`

#### 1.2 添加自定义工具

```python
from langchain_core.tools import tool
from deepagents import create_deep_agent
from langchain_core.messages import HumanMessage

@tool
def get_weather(location: str) -> str:
    """获取指定地点的天气信息"""
    # 模拟天气数据
    weather_data = {
        "北京": "晴天，气温25°C",
        "上海": "多云，气温28°C",
        "广州": "雨天，气温22°C"
    }
    return weather_data.get(location, "未知地点")

# 创建带有自定义工具的智能体
agent = create_deep_agent(tools=[get_weather])

result = agent.invoke({
    "messages": [HumanMessage(content="请查询北京的天气")]
})
```

#### 1.3 完整的研究智能体示例

基于 `examples/research/research_agent.py` 的实际应用：

```python
import os
from typing import Literal
from deepagents import create_deep_agent
from tavily import TavilyClient

# 初始化搜索客户端
tavily_client = TavilyClient(api_key=os.environ["TAVILY_API_KEY"])

# 定义搜索工具
def internet_search(
    query: str,
    max_results: int = 5,
    topic: Literal["general", "news", "finance"] = "general",
    include_raw_content: bool = False,
):
    """执行网络搜索"""
    search_docs = tavily_client.search(
        query,
        max_results=max_results,
        include_raw_content=include_raw_content,
        topic=topic,
    )
    return search_docs

# 定义子智能体配置
research_sub_agent = {
    "name": "research-agent",
    "description": "用于深入研究问题，一次只处理一个主题",
    "system_prompt": "你是专业研究员，请进行深入研究并给出详细答案",
    "tools": [internet_search],
}

critique_sub_agent = {
    "name": "critique-agent",
    "description": "用于批判和评估报告质量",
    "system_prompt": "你是专业编辑，请评估报告并提供改进建议",
}

# 研究提示词
research_instructions = """你是专业研究员，请进行深入研究并撰写报告。

首先将用户问题写入 question.txt，
使用 research-agent 进行深度研究，
编写最终报告到 final_report.md，
使用 critique-agent 评估报告质量。"""

# 创建研究智能体
agent = create_deep_agent(
    tools=[internet_search],
    system_prompt=research_instructions,
    subagents=[research_sub_agent, critique_sub_agent],
)

# 使用研究智能体
result = agent.invoke({
    "messages": [HumanMessage(content="请研究人工智能在医疗领域的最新进展")]
})
```

### 2. 内部执行流程剖析

#### 2.1 智能体创建流程

当我们调用 `create_deep_agent()` 时，内部执行以下步骤：

**第一步：默认配置设置**
```python
# 如果没有指定模型，使用默认的 Claude Sonnet 4
if model is None:
    model = get_default_model()  # Claude Sonnet 4.5，max_tokens=20000
```

**第二步：中间件栈构建**
智能体按顺序构建中间件栈：

```python
deepagent_middleware = [
    # 1. 任务规划中间件 - 提供任务分解能力
    TodoListMiddleware(),

    # 2. 文件系统中间件 - 提供文件操作工具
    FilesystemMiddleware(backend=backend),

    # 3. 子智能体中间件 - 支持任务委托
    SubAgentMiddleware(
        default_model=model,
        default_tools=tools,
        subagents=subagents if subagents is not None else [],
        default_middleware=[
            TodoListMiddleware(),
            FilesystemMiddleware(backend=backend),
            SummarizationMiddleware(model=model, max_tokens_before_summary=170000, messages_to_keep=6),
            AnthropicPromptCachingMiddleware(unsupported_model_behavior="ignore"),
            PatchToolCallsMiddleware(),
        ],
        default_interrupt_on=interrupt_on,
        general_purpose_agent=True,
    ),

    # 4. 摘要中间件 - 管理对话历史
    SummarizationMiddleware(model=model, max_tokens_before_summary=170000, messages_to_keep=6),

    # 5. 提示缓存中间件 - 优化性能
    AnthropicPromptCachingMiddleware(unsupported_model_behavior="ignore"),

    # 6. 工具调用补丁中间件 - 修复悬挂调用
    PatchToolCallsMiddleware(),
]
```

**第三步：LangGraph 智能体创建**
```python
return create_agent(
    model,
    system_prompt=system_prompt + "\n\n" + BASE_AGENT_PROMPT,
    tools=tools,
    middleware=deepagent_middleware,
    response_format=response_format,
    context_schema=context_schema,
    checkpointer=checkpointer,
    store=store,
    debug=debug,
    name=name,
    cache=cache,
).with_config({"recursion_limit": 1000})
```

#### 2.2 运行时执行流程

当用户发送消息时，执行以下流程：

**中间件链式处理：**

1. **PatchToolCallsMiddleware.before_agent()**
   - 检查消息历史中的悬挂工具调用
   - 自动生成取消消息

2. **FilesystemMiddleware 处理**
   - 注入文件操作工具：`ls`, `read_file`, `write_file`, `edit_file`, `glob_search`, `grep_search`
   - 根据配置的后端（State/Filesystem/Store/Composite）处理文件操作

3. **TodoListMiddleware 处理**
   - 注入 `write_todos` 工具用于任务规划
   - 管理任务状态和进度跟踪

4. **SubAgentMiddleware 处理**
   - 注入 `task` 工具用于启动子智能体
   - 管理子智能体的生命周期和上下文隔离

**工具执行流程：**

以文件读取为例：
```python
# 用户请求读取文件
agent.invoke({"messages": [HumanMessage(content="请读取 /data/config.txt")]})

# 执行流程：
# 1. 中间件注入 read_file 工具
# 2. 智能体决定使用 read_file 工具
# 3. 工具调用传递给 FilesystemMiddleware
# 4. 中间件根据配置的后端处理：
#    - StateBackend: 从 runtime.state["files"] 读取
#    - FilesystemBackend: 从物理文件系统读取
#    - StoreBackend: 从 LangGraph Store 读取
#    - CompositeBackend: 根据路径前缀路由到相应后端
# 5. 返回格式化的文件内容（带行号）
```

**子智能体执行流程：**

```python
# 智能体决定使用子智能体
task_result = agent.invoke({
    "messages": [HumanMessage(content="请研究人工智能的最新进展")]
})

# 子智能体执行流程：
# 1. 主智能体调用 task 工具
# 2. SubAgentMiddleware 接收调用请求
# 3. 创建新的智能体实例：
#    - 使用子智能体的系统提示
#    - 继承默认中间件栈
#    - 隔离的上下文窗口
# 4. 子智能体独立完成任务
# 5. 返回结果给主智能体
# 6. 主智能体整合结果并回复用户
```

### 3. 高级功能和定制示例

#### 3.1 自定义后端配置

```python
from deepagents import create_deep_agent
from deepagents.backends import FilesystemBackend, StateBackend, CompositeBackend

# 组合后端示例
composite_backend = CompositeBackend(
    default=StateBackend(runtime),           # 默认临时存储
    routes={
        "/persistent/": StoreBackend(runtime),  # 持久化存储
        "/workspace/": FilesystemBackend("./workspace"),  # 工作区文件
    }
)

agent = create_deep_agent(backend=composite_backend)
```

#### 3.2 自定义中间件

```python
from langchain.agents.middleware import AgentMiddleware
from langchain.agents.middleware.types import AgentState
from langgraph.runtime import Runtime
from langchain_core.tools import tool

# 自定义中间件
class LoggingMiddleware(AgentMiddleware):
    """记录所有工具调用的中间件"""

    def before_agent(self, state: AgentState, runtime):
        print("智能体开始执行...")
        return None

    def after_agent(self, state: AgentState, runtime):
        print("智能体执行完成")
        return None

# 带有自定义工具的中间件
class CustomToolsMiddleware(AgentMiddleware):
    """注入自定义工具的中间件"""

    @tool
    def get_system_info(self) -> str:
        """获取系统信息"""
        return "系统运行正常，内存使用率: 45%"

    def get_tools(self, state: AgentState, runtime):
        return [self.get_system_info]

# 使用自定义中间件
agent = create_deep_agent(
    middleware=[LoggingMiddleware(), CustomToolsMiddleware()]
)
```

#### 3.3 人机交互（HITL）配置

```python
from langchain.agents.middleware import InterruptOnConfig, HumanInTheLoopMiddleware

# 配置需要人工确认的工具
interrupt_config = {
    "write_file": InterruptOnConfig(
        require_approval=True,
        approval_message="是否确认写入文件？"
    ),
    "execute_bash": InterruptOnConfig(
        require_approval=True,
        approval_message="是否确认执行此命令？"
    )
}

# 创建带有人工交互的智能体
agent = create_deep_agent(
    interrupt_on=interrupt_config,
    # HumanInTheLoopMiddleware 会自动添加到中间件栈末尾
)
```

#### 3.4 流式处理和状态监控

```python
# 流式处理示例
def stream_agent_response(agent, user_message):
    """流式处理智能体响应"""
    for chunk in agent.stream({
        "messages": [HumanMessage(content=user_message)]
    }):
        if "messages" in chunk:
            for message in chunk["messages"]:
                if message.type == "ai":
                    print(message.content, end="", flush=True)
        elif "todos" in chunk:
            print(f"\n[任务更新] {chunk['todos']}")
        elif "files" in chunk:
            print(f"\n[文件更新] {list(chunk['files'].keys())}")

# 使用流式处理
agent = create_deep_agent()
stream_agent_response(agent, "请帮我创建一个Python项目的基本结构")
```

#### 3.5 检查点和持久化

```python
from langgraph.checkpoint.memory import MemorySaver
from langgraph.store.memory import MemoryStore

# 创建检查点和存储
checkpointer = MemorySaver()
store = MemoryStore()

# 创建持久化智能体
agent = create_deep_agent(
    checkpointer=checkpointer,
    store=store,
    backend=StateBackend  # 使用状态后端配合检查点
)

# 使用线程ID进行持久化对话
thread_id = "user_session_123"
config = {"configurable": {"thread_id": thread_id}}

# 第一次对话
result1 = agent.invoke({
    "messages": [HumanMessage(content="我的名字是张三")]
}, config)

# 后续对话（会记住之前的内容）
result2 = agent.invoke({
    "messages": [HumanMessage(content="你还记得我的名字吗？")]
}, config)
```

`★ Insight ─────────────────────────────────────`
• DeepAgents 的中间件架构就像搭积木一样，每个中间件都有明确的职责，可以灵活组合
• 组合后端的设计让不同类型的文件可以采用最优的存储策略，临时文件用内存，重要文件用持久化存储
• 检查点和流式处理功能使得 DeepAgents 可以构建生产级的对话系统，支持状态恢复和实时响应
`─────────────────────────────────────────────────`

### 4. 实际应用场景示例

#### 4.1 代码审查助手

```python
from deepagents import create_deep_agent
from langchain_core.tools import tool

@tool
def analyze_code(file_path: str) -> str:
    """分析代码文件并提供建议"""
    # 实现代码分析逻辑
    pass

@tool
def run_tests(project_path: str) -> str:
    """运行项目测试"""
    # 实现测试运行逻辑
    pass

code_review_agent = create_deep_agent(
    tools=[analyze_code, run_tests],
    system_prompt="""你是代码审查专家，请：
    1. 分析代码质量
    2. 检查潜在问题
    3. 运行测试验证
    4. 提供改进建议""",
    subagents=[
        {
            "name": "security-analyzer",
            "description": "专门进行安全分析",
            "system_prompt": "你是安全专家，请检查代码中的安全问题",
            "tools": [analyze_code],
        }
    ]
)
```

#### 4.2 数据分析助手

```python
import pandas as pd
from deepagents import create_deep_agent

@tool
def load_data(file_path: str) -> str:
    """加载数据文件"""
    df = pd.read_csv(file_path)
    return f"数据加载成功，形状: {df.shape}，列名: {list(df.columns)}"

@tool
def analyze_data(operation: str, target: str) -> str:
    """执行数据分析操作"""
    # 实现数据分析逻辑
    pass

data_analyst = create_deep_agent(
    tools=[load_data, analyze_data],
    backend=FilesystemBackend("./data"),  # 指定数据文件目录
    system_prompt="你是数据分析师，请帮助用户进行数据分析"
)
```

### 5. 最佳实践和注意事项

#### 5.1 性能优化建议

**1. 合理使用摘要中间件**
```python
# 对于长对话，调整摘要阈值
agent = create_deep_agent(
    # 其他配置...
    # 中间件栈中的 SummarizationMiddleware 会自动管理对话长度
)
```

**2. 使用提示缓存**
```python
# AnthropicPromptCachingMiddleware 会自动启用缓存
# 在重复场景下可以显著提升性能和降低成本
```

**3. 子智能体的合理使用**
```python
# 复杂任务分解为子智能体，避免主智能体上下文过载
subagents = [
    {
        "name": "data-collector",
        "description": "专门收集数据",
        "system_prompt": "专注数据收集，不要进行分析",
    },
    {
        "name": "data-analyzer",
        "description": "专门分析数据",
        "system_prompt": "专注数据分析，假设数据已经收集完毕",
    }
]
```

#### 5.2 安全注意事项

**1. 文件系统安全**
```python
# 使用虚拟模式限制文件访问范围
safe_backend = FilesystemBackend(
    root_dir="./safe_workspace",
    virtual_mode=True,  # 启用沙箱模式
    max_file_size_mb=5  # 限制文件大小
)
```

**2. 工具调用确认**
```python
# 对危险操作启用人工确认
interrupt_config = {
    "write_file": InterruptOnConfig(require_approval=True),
    "edit_file": InterruptOnConfig(require_approval=True),
}
```

#### 5.3 调试和监控

**1. 启用调试模式**
```python
agent = create_deep_agent(debug=True)  # 启用详细日志
```

**2. 状态监控**
```python
# 监控智能体状态变化
for event in agent.stream({"messages": [HumanMessage(content="测试")] }):
    print(f"Event: {event}")
```

### 总结

DeepAgents 提供了一个强大而灵活的 AI 智能体框架，通过中间件架构实现了高度的可定制性。核心优势包括：

1. **开箱即用**：默认配置已经包含完整的功能集
2. **高度可定制**：支持自定义工具、中间件和后端
3. **生产就绪**：内置检查点、流式处理和安全机制
4. **模块化设计**：清晰的架构便于扩展和维护

通过合理配置和使用，DeepAgents 可以构建从简单的聊天机器人到复杂的多智能体协作系统的各种 AI 应用。